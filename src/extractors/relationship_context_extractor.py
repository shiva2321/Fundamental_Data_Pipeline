"""
Relationship Context Extractor

Extracts relationship type and strength between companies mentioned
in SEC filing text using pattern matching and NLP techniques.
"""
import logging
import re
from typing import List, Dict, Tuple, Optional
from enum import Enum

logger = logging.getLogger(__name__)


class RelationshipType(Enum):
    """Enumeration of relationship types between companies"""
    SUPPLIER = "supplier"
    CUSTOMER = "customer"
    COMPETITOR = "competitor"
    PARTNER = "partner"
    INVESTOR = "investor"
    SUBSIDIARY = "subsidiary"
    PARENT = "parent"
    UNKNOWN = "unknown"


class RelationshipContextExtractor:
    """
    Extract relationship type and context from sentences containing
    company mentions.

    Handles:
    - Supplier relationships
    - Customer relationships
    - Competitor relationships
    - Partnership relationships
    - Investor relationships
    - Parent-subsidiary relationships
    """

    # Define relationship keywords and patterns
    RELATIONSHIP_PATTERNS = {
        'supplier': {
            'strong': [
                r'(?:depend|rely|source|procure|obtain).*?(?:from|at|with)\s+',
                r'(?:supplies?|supplied\s+by|supplies\s+|manufacturing\s+by|produced\s+by|manufactured\s+by)',
                r'(?:primary|key|main|critical)\s+suppliers?',
                r'sourced\s+from',
                r'(?:procurement|purchase|purchasing)\s+from',
                r'(?:depend|depends)\s+on.*?for.*?components?|parts?|materials?',
            ],
            'medium': [
                r'purchase[d]?\s+(?:from|at)',
                r'(?:vendor|supplier|providers?)',
                r'sourcing',
                r'supply chain',
            ],
            'weight': 0.90
        },
        'customer': {
            'strong': [
                r'(?:sold|sell|sells|selling|sales)\s+(?:to|in)',
                r'(?:primary|key|main|largest)\s+(?:customers?|clients?|end[- ]users?)',
                r'revenue.*?(?:from|generated by|attributable to)',
                r'(?:customer|client)\s+base.*?(?:includes?|consists?|comprises?)',
                r'sale[s]?.*?to',
                r'(?:represent|represented|comprised|account|accounting)\s+(?:approximately\s+)?(?:\d+(?:\.\d+)?)\s*%\s+of\s+(?:revenue|sales)',
            ],
            'medium': [
                r'(?:customer|client)\s+base',
                r'end[- ]user',
                r'customer[s]?',
            ],
            'weight': 0.85
        },
        'competitor': {
            'strong': [
                r'(?:competes?|compete[s]?|competing|competition)\s+(?:with|against)',
                r'(?:competitor|competitors|competitive)',
                r'(?:primary|main|key)\s+(?:competitor|competitive)',
                r'compete[s]?\s+(?:directly|fiercely)',
            ],
            'medium': [
                r'(?:competitive|compete)',
                r'rivalry',
                r'alternative[s]?',
            ],
            'weight': 0.80
        },
        'partner': {
            'strong': [
                r'(?:partner|partnership)',
                r'(?:joint\s+venture|JV)',
                r'(?:collaboration|collaborative)',
                r'(?:strategic\s+alliance)',
                r'work[s]?.*?together',
                r'(?:cooperat|cooperative)',
            ],
            'medium': [
                r'(?:cooperat|cooperative)',
                r'(?:affiliate|affiliated)',
                r'alliance',
            ],
            'weight': 0.75
        },
        'investor': {
            'strong': [
                r'(?:investor|holding|stake)',
                r'(?:owns?|ownership)\s+(?:\d+(?:\.\d+)?)\s*%',
                r'share?holder',
                r'institutional\s+investor',
                r'investment\s+in',
            ],
            'medium': [
                r'investor',
                r'investment',
            ],
            'weight': 0.70
        },
    }

    def __init__(self):
        """Initialize the relationship context extractor"""
        logger.info("RelationshipContextExtractor initialized")

    def extract_relationships(self, text: str, company_mentions: List[Tuple[str, str, float]],
                              source_cik: str, max_relationships: int = 100) -> List[Dict]:
        """
        Extract relationships between mentioned companies.

        Args:
            text: Filing text
            company_mentions: List of (cik, name, confidence) tuples
            source_cik: CIK of company being analyzed
            max_relationships: Maximum relationships to return

        Returns:
            List of relationship dictionaries
        """
        relationships = []
        sentences = self._smart_split_sentences(text)

        logger.debug(f"Processing {len(sentences)} sentences for relationships")

        for sentence in sentences:
            # Find which companies are mentioned in this sentence
            mentioned_in_sentence = [
                (cik, name, conf) for cik, name, conf in company_mentions
                if self._is_mentioned_in_sentence(name, sentence)
            ]

            # If multiple companies mentioned, likely a relationship
            if len(mentioned_in_sentence) >= 2:
                for i, (cik1, name1, conf1) in enumerate(mentioned_in_sentence):
                    for cik2, name2, conf2 in mentioned_in_sentence[i+1:]:
                        rel_type, strength = self._determine_relationship_type(sentence)

                        if rel_type != RelationshipType.UNKNOWN:
                            relationships.append({
                                'source_cik': cik1,
                                'source_name': name1,  # ✅ Add source name
                                'target_cik': cik2,
                                'target_name': name2,  # ✅ Add target name
                                'relationship_type': rel_type.value,
                                'confidence_score': strength * min(conf1, conf2),
                                'context': sentence[:300],
                                'mention_confidence': min(conf1, conf2)
                            })

            # Also check for relationships with source company
            if source_cik not in [c[0] for c in mentioned_in_sentence]:
                continue

            for cik, name, conf in mentioned_in_sentence:
                if cik == source_cik:
                    continue

                rel_type, strength = self._determine_relationship_type(sentence)
                if rel_type != RelationshipType.UNKNOWN:
                    relationships.append({
                        'source_cik': source_cik,
                        'source_name': 'Source Company',  # ✅ Add source name
                        'target_cik': cik,
                        'target_name': name,  # ✅ Add target name
                        'relationship_type': rel_type.value,
                        'confidence_score': strength * conf,
                        'context': sentence[:300],
                        'mention_confidence': conf
                    })

        logger.debug(f"Extracted {len(relationships)} relationships")
        return relationships[:max_relationships]

    def _smart_split_sentences(self, text: str) -> List[str]:
        """
        Split text into sentences, handling abbreviations.

        Args:
            text: Text to split

        Returns:
            List of sentence strings
        """
        # Remove XML tags
        text = re.sub(r'<[^>]+>', '', text)

        # Split on sentence boundaries but preserve meaning
        # This pattern looks for periods followed by space and capital letter
        sentences = re.split(r'(?<=[.!?])\s+(?=[A-Z])', text)

        return [s.strip() for s in sentences if s.strip() and len(s.strip()) > 20]

    def _is_mentioned_in_sentence(self, company_name: str, sentence: str) -> bool:
        """Check if company is mentioned in sentence"""
        pattern = r'\b' + re.escape(company_name) + r'\b'
        return bool(re.search(pattern, sentence, re.IGNORECASE))

    def _determine_relationship_type(self, sentence: str) -> Tuple[RelationshipType, float]:
        """
        Determine primary relationship type from sentence.

        Returns:
            Tuple of (RelationshipType, strength_score 0.0-1.0)
        """
        best_type = RelationshipType.UNKNOWN
        best_score = 0.0

        for rel_type_str, patterns in self.RELATIONSHIP_PATTERNS.items():
            score = 0.0

            # Check strong patterns first
            for pattern in patterns.get('strong', []):
                try:
                    if re.search(pattern, sentence, re.IGNORECASE):
                        score = 0.90 * patterns.get('weight', 1.0)
                        break
                except re.error:
                    logger.warning(f"Invalid regex pattern: {pattern}")
                    continue

            # Check medium patterns if no strong match
            if score == 0:
                for pattern in patterns.get('medium', []):
                    try:
                        if re.search(pattern, sentence, re.IGNORECASE):
                            score = 0.65 * patterns.get('weight', 1.0)
                            break
                    except re.error:
                        continue

            if score > best_score:
                best_score = score
                best_type = RelationshipType(rel_type_str)

        return best_type, best_score


class RelationshipStrengthCalculator:
    """Calculate relationship strength based on multiple factors"""

    @staticmethod
    def calculate_strength(sentence_count: int, revenue_impact: float = 0.0,
                          material_dependency: bool = False) -> float:
        """
        Calculate overall relationship strength.

        Args:
            sentence_count: Number of times relationship mentioned
            revenue_impact: Estimated revenue percentage (0-100)
            material_dependency: Is this a material/critical dependency?

        Returns:
            Strength score 0.0-1.0
        """
        strength = 0.0

        # Mention frequency component
        if sentence_count >= 5:
            strength += 0.4
        elif sentence_count >= 3:
            strength += 0.3
        elif sentence_count >= 1:
            strength += 0.2

        # Revenue impact component
        if revenue_impact > 0:
            strength += min(0.3, revenue_impact / 100.0)

        # Material dependency component
        if material_dependency:
            strength += 0.3

        return min(1.0, strength)

